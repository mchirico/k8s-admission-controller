package main

import (
	"encoding/json"
	"fmt"
	"github.com/golang/gddo/httputil/header"
	"github.com/pkg/errors"
	"net/http/httputil"

	"io"
	"log"
	"net/http"
	"os"
)

type AutoGenerated struct {
	Request struct {
		UID    string `json:"uid"`
		Object struct {
			Metadata struct {
				Labels struct {
					Billing string `json:"billing"`
				} `json:"labels"`
			} `json:"metadata"`
		} `json:"object"`
	} `json:"request"`
}

func decodeJSON(r *http.Request) (AutoGenerated, error) {

	var m AutoGenerated
	err := json.NewDecoder(r.Body).Decode(&m)

	return m, err

}

func checkHeader(r *http.Request) error {
	if r.Header.Get("Content-Type") != "" {
		value, _ := header.ParseValueAndParams(r.Header, "Content-Type")
		if value != "application/json" {
			msg := "Content-Type header is not application/json"
			return errors.New(msg)
		}
		return nil
	}
	return errors.New("Header blank")
}

func LookForBillingLabel(r *http.Request) (string, error) {
	data, err := decodeJSON(r)
	v := `{"apiVersion": "admission.k8s.io/v1","kind": "AdmissionReview","response": {"allowed": %t, "uid": %s, "status": {"message": %q}}})`

	allowed := false
	uid := ""
	msg := "Not valid"

	if len(data.Request.Object.Metadata.Labels.Billing) != 0 {
		allowed = true
		msg = "valid"
	}
	if len(data.Request.UID) != 0 {
		uid = data.Request.UID
	}

	return fmt.Sprintf(v, allowed, uid, msg), err

}

func LogAllData(r *http.Request) {
	dump, _ := httputil.DumpRequest(r, true)
	log.Println("dump: ", string(dump))
}

func Validate(w http.ResponseWriter, r *http.Request) {

	LogAllData(r)
	err := checkHeader(r)
	if err != nil {
		return
	}

	data, err := LookForBillingLabel(r)
	if err != nil {
		return
	}

	io.WriteString(w, data)

}

func main() {
	name, err := os.Hostname()
	if err != nil {
		panic(err)
	}

	http.HandleFunc("/Validate", Validate)

	log.Printf("About to listen on 5000. Go to https://%s:5000/", name)
	err = http.ListenAndServeTLS(":5000", "./certs/server_certificate.pem", "./certs/server_key.pem", nil)
	log.Fatal(err)
}
